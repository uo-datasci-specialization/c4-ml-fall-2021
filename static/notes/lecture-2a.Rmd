---
title: Data Pre-processing (Feature Engineering)
subtitle: Applied Machine Learning for Educational Data Science
author:
  name: Cengiz Zopluoglu
  affiliation: University of Oregon | EDLD 654
date: 08/23/2021 ## Or "Lecture no."
output: 
  html_document:
    keep_md: false
    theme: journal
    highlight: haddock
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    extra_dependencies: ["amssymb","animate"]
    keep_tex: false ## Change to true if want keep intermediate .tex file
    toc: true
    toc_depth: 3
    dev: cairo_pdf
always_allow_html: true
urlcolor: blue
mainfont: cochineal
sansfont: Fira Sans
monofont: Fira Code ## Although, see: https://tex.stackexchange.com/q/294362

## Automatically knit to both formats:
knit: (function(inputFile, encoding) {
 rmarkdown::render(inputFile, encoding = encoding, 
 output_format = 'all') 
 })
---



```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position=c('top','right'))
```

`r paste('[Updated:',format(Sys.time(),'%a, %b %d, %Y - %H:%M:%S'),']')`

<style>

.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {
    z-index: 2;
    color: #fff;
    background-color: #FC4445;
    border-color: #97CAEF;
}

#infobox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid black;
  border-radius: 10px;
  background: #E6F6DC 5px center/3em no-repeat;
}

</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = "",fig.align='center')
require(here)
require(ggplot2)
require(plot3D)
require(kableExtra)
require(knitr)
require(giski)
require(magick)
require(gridExtra)
options(scipen=99)

# Resources:

  # http://www.feat.engineering/index.html
  # https://bradleyboehmke.github.io/HOML/engineering.html
  # Applied Predictive Modeling, Chapter 3

```

# 1. Scales of Measurement and Types of Variables

It is important to understand the nature of variables and how they were measured and represented in a dataset. In social sciences, in particular psychology, there is a methodological consensus about the framework provided by [Stevens (1946)](https://www.jstor.org/stable/1671815), also see [Michell (2002)](https://doi.org/10.1080/00049530210001706563) for an in-depth discussion. According to Stevens' definition, there are four levels of measurement: nominal, ordinal, interval, and ratio. Whether a variable is considered having a nominal, ordinal, interval, or ratio scale depends on the character of the empirical operations performed while constructing the variable. 

- Nominal scale: Variables with a nominal scale cannot be be meaningfully added, subtracted, divided, or multiplied. Also, there is no hierarchical order among the assigned values. Most variables that contains labels for individual observations can be considered as nominal, e.g., hair color, city, state, ethnicity.

- Ordinal scale: Variables with an ordinal scale also represent labels; however, there is a meaningful hierarchy among the assigned values. For instance, if a variable is coded as Low, Medium, and High, they are simply labels but we know that High represents something more than Medium, and Medium represents something higher than Low (High > Medium > Low). On the other side, the distance between the assigned values do not necessarily represent the same amount of difference. Other examples of variables that can be considered as ordinal are letter grades (A-F), scores from likert type items (Strongly agree, agree, disagree, strongly disagree), education status(high school, college, master's, PhD), cancer stage (stage1, stage2, stage3), order of finish in a competition (1st, 2nd, 3rd).

- Interval scale: Variables with an ordinal scale represents quantities with equal measurement units but they don't have an absolute zero point. For instance, a typical example of an interval scale is temperature measured on the Fahrenheit scale. The difference between 20F and 30F is the same difference as the difference between 60F and 70F. However, 0F does not indicate no heat.

- Ratio scale: Variables with a ratio scale represents quantities with equal measurement units and have an absolute zero. Due to the nature of the existence of absolute zero point that represent 'nothing', ratio of measurements are also meaningful. Typical examples are height, mass, distance, length.

Below table provides a summary of properties for each scale.

|          | Indicating Difference | Indicating Direction of Difference | Indicating Amount of Difference | Has absolute zero |
|----------|:---------------------:|:----------------------------------:|:-------------------------------:|:-----------------:|
| Nominal  | X                      |                                    |                                 |                   |
| Ordinal  | X                     | X                                  |                                 |                   |
| Interval | X                     | X                                  | X                               |                   |
| Ratio    | X                     | X                                  | X                               | X                 |

In this class, we classify the variables in two types: **Categorical** and **Continuous**. The variables with a nominal or ordinal scale are considered as **Categorical** and the variables with an interval or ratio scale are considered as **Continuous**.


***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

In the following sections, you will see some R code to process different types of variables using the base R functions to introduce certain types of coding schemes. At the end, I will introduce the `recipes` package to provide a more complete picture of how to do all these different types of encoding in a more efficient manner for this specific dataset.

</div>
***

# 2. Processing Categorical Variables

When there are categorical predictors in a dataset, it is important to translate them into numerical codes. When encoding categorical predictors, we try to preserve as much information as possible from its labels. Therefore, different strategies may be used for categorical variables with different ordinal scales.

## 2.1 One-hot encoding (Dummy Variables)

A dummy variable is a synthetic variable with two outcomes (0 and 1) to represent a group membership. When there is a nominal variable with *N* levels, it is typical to create *N* dummy variables to represent the information in the nominal variable. Each dummy variable represents a membership to one of the levels in the nominal variable. These dummy variables can be used as features in predictive models.

In its simplest case, consider variable `Race` in the Recidivism dataset with two levels: Black and White. We can create two dummy variables such that the first dummy variable represents whether or not an individual is Black and the second dummy variable represents whether or not the individual is White.


|        | Dummy Variable 1 | Dummy Variable 2 |
|--------|:----------------:|:----------------:|
| Black  |     1            |       0
| White  |     0            |       1          |


```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

recidivism <- read.csv('https://raw.githubusercontent.com/uo-datasci-specialization/c4-ml-fall-2021/main/data/recidivism_y1 removed.csv',header=TRUE)

table(recidivism$Race)

recidivism$black <- ifelse(recidivism$Race=='BLACK',1,0)
recidivism$white <- ifelse(recidivism$Race=='WHITE',1,0)

head(recidivism[,c('Race','black','white')])

table(recidivism$black)
table(recidivism$white)
```

Let's consider another example from the Recidivism dataset. Variable `Prison_Offense` has five categories: Violent/Sex, Violent/Non-Sex, Property, Drug, Other. We can create five dummy variables using the following coding scheme. 

|                  | Dummy Variable 1 | Dummy Variable 2 | Dummy Variable 3 | Dummy Variable 4 | Dummy Variable 5 |
|------------------|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:|
| Violent/Sex      |     1            |       0          |     0            |     0            |     0            |
| Violent/Non-Sex  |     0            |       1          |     0            |     0            |     0            |
| Property         |     0            |     0            |     1            |     0            |     0            |
| Drug             |     0            |     0            |     0            |     1            |     0            |
| Other            |     0            |     0            |     0            |     0            |     1            |

Note that `Prison_Offence` is missing for a number of observations. You can fill-in the missing values prior to creating dummy variables using one of the methods we will discuss later. Alternatively, we can define Missing as the sixth category to preserve that information.

|                  | Dummy Variable 1 | Dummy Variable 2 | Dummy Variable 3 | Dummy Variable 4 | Dummy Variable 5 |Dummy Variable 6 |
|------------------|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:
| Violent/Sex      |     1            |       0          |     0            |     0            |     0            |    0            |
| Violent/Non-Sex  |     0            |       1          |     0            |     0            |     0            |    0            |
| Property         |     0            |     0            |     1            |     0            |     0            |    0            |
| Drug             |     0            |     0            |     0            |     1            |     0            |    0            |
| Other            |     0            |     0            |     0            |     0            |     1            |    0            |
| Missing          |     0            |     0            |     0            |     0            |     0            |    1            |


```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

table(recidivism$Prison_Offense)
names(table(recidivism$Prison_Offense))

recidivism$off_viosex   <- ifelse(recidivism$Prison_Offense=='Violent/Sex',1,0)
recidivism$off_vionosex <- ifelse(recidivism$Prison_Offense=='Violent/Non-Sex',1,0)
recidivism$off_property <- ifelse(recidivism$Prison_Offense=='Property',1,0)
recidivism$off_drug     <- ifelse(recidivism$Prison_Offense=='Drug',1,0)
recidivism$off_other    <- ifelse(recidivism$Prison_Offense=='Other',1,0)
recidivism$off_missing  <- ifelse(recidivism$Prison_Offense=='',1,0)

head(recidivism[,c('Prison_Offense','off_viosex','off_vionosex','off_property','off_drug','off_other','off_missing')],10)

```

In some cases, when you have geographical location with a reasonable number of categories (e.g., counties or cities in a state, schools in a district), you can also create dummy variables to represent this information. In our case, the Recidivism dataset has a variable called `Residence_PUMA` indicating [Public Use Microdata Area (PUMA)](https://www.census.gov/programs-surveys/geography/guidance/geo-areas/pumas.html) for the residence address at the time individual was released. There is a total of 25 unique codes (1-25) for this variable; however, these numbers are just labels. So, one can create 25 different dummy variables to represent 25 different PUMAs.

***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

When you fit a typical regression model without regularizaton using ordinary least-squares (OLS), a typical practice is to drop a dummy variable for one of the levels. So, for instance, if there are *N* levels for a nominal variable, you only have to create *(N-1)* dummy variables, as the Nth one has redundant information. The information regarding to the excluded category is represented in the intercept term. It creates a problem when you put all *N* dummy variables into the model, because the OLS procedure tries to invert a singular matrix and you will likely get an error message. 

On the other hand, this is not an issue when you fit a regularized regression model, which will be the case in this class. Therefore, you do not need to drop one of the dummy variables and can include all of them in the analysis. In fact, it may be beneficial to keep the dummy variables for all categories in the model when regularization is used in regression. Otherwise, the model may produce different predictions depending on which category is excluded.

</div>
***

## 2.2. Label encoding

When the variable of interest is ordinal and there is a hierarchy among the levels, we can still use one-hot encoding to create a set of dummy variables to represent the information in the ordinal variable. However, dummy variables will not provide any information regarding the hierarchy among categories. 

For instance, consider the variable `Age_At_Release` in the Recidivism dataset. It is coded as 7 different age intervals in the dataset: 18-22, 23-27, 28-32, 33-37, 38-42, 43-47, 48 or older. One can create 7 dummy variables to represent each category in this variable. Alternatively, one can assign a numeric variable to each category that may represent the information in these categories. For instance, one can assign numbers from 1 to 7, respectively. Or, one can choose the midpoint of each interval to represent each category (e.g., 20,25,31,35,40,45,60).

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show', message=FALSE, warning=FALSE}

require(dplyr)
table(recidivism$Age_at_Release)

#?dplyr::recode
recidivism$age <- recode(recidivism$Age_at_Release,
                         '18-22' = 20,
                         '23-27' = 25,
                         '28-32' = 30,
                         '33-37' = 35,
                         '38-42' = 40,
                         '43-47' = 45,
                         '48 or older' = 60)

hist(recidivism$age,main='',xlab='Age at Release (Label Encoding)')
```

Another example would be the variable `Education Level`. It has three different levels: At least some college, High School Diploma, Less than HS diploma. One can create three dummy variables to represent each level. Alternatively, one can assign 1, 2, and 3, respectively. Or, one can assign a number for the approximate years of schooling for each level such as 9, 12, and 15.   

```{r, echo=TRUE,eval=knitr::is_html_output(),class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

table(recidivism$Education_Level)

recidivism$edu <- recode(recidivism$Education_Level,
                         'At least some college' = 14,
                         'High School Diploma'   = 12,
                         'Less than HS diploma'  = 8)

hist(recidivism$edu,main='',xlab='Education Level (Label Encoding)')
```

## 2.3. Polynomial Contrasts

Another way of encoding an ordinal variable is to use polynomial contrasts. The polynomial contrasts may be helpful if one wants to explore whether or not there is a linear, quadratic, cubic, etc. relationship between the predictor variable and outcome variable. You can use `stat::poly()` function in R to obtain the set of polynomial contrasts. If there are *N* levels in an ordinal variable, then you can get polynomials up to degree *N-1*. 

For instance, suppose you have an ordinal variable with three levels: Low, Medium, and High. Then, `stat::poly(x=1:3,degree=2)` will return the polynomial contrasts for the linear and quadratic terms. Notice that the input values for the `poly` function is a vector of numeric values that correspond to the levels in the ordinal variable, and the degree of polynomial terms requested. For this examle, it creates two sets of vectors to represent this ordinal variable. Note that the sum of the squares within each column is equal to 1, and the dot product of the contrast vectors is equal to 0. In other words, the polynomial terms represent a set of **orthonormal vectors**.

|        | Linear           | Quadratic        |
|--------|:----------------:|:----------------:|
| Low    |     -0.707       |       0.408      |
| Medium |       0          |       -0.816     |
| High   |     0.707        |       0.408      |

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

ctr <- poly(1:3,2)
ctr

sum(ctr[,1]^2)
sum(ctr[,2]^2)

sum(ctr[,1]*ctr[,2])

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

linear <- ggplot()+
  geom_point(aes(x=1:3,y=ctr[,1]),cex=3)+
  geom_line(aes(x=1:3,y=ctr[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Linear Term')

quad <- ggplot()+
  geom_point(aes(x=1:3,y=ctr[,2]),cex=3)+
  geom_line(aes(x=1:3,y=ctr[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Quadratic Term')

grid.arrange(linear,quad,nrow=1)
```

If we consider the variable `Age_At_Release` with 7 different levels, then we can have polynomial terms up to the 6th degree. 

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

ctr <- poly(1:7,6)
ctr
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

linear <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,1]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Linear Term')

quad <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,2]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Quadratic Term')

cubic <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,3]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,3]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Cubic Term')

fourth <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,4]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,4]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('4th Degree Term')

fifth <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,5]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,5]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('5th Degree Term')


sixth <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,6]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,6]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('6th Degree Term')


grid.arrange(linear,quad,cubic,fourth,fifth,sixth,nrow=3,ncol=2)
```

When we apply this to a variable in the dataset, these columns are rescaled such that they are orthonormal vectors. See below for an example:

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

# First, recode the Age_at_Release so that its levels are represented by numbers
# poly() doesn't work with character vectors

recidivism$age <- dplyr::recode(recidivism$Age_at_Release,
                                '18-22' = 1,
                                '23-27' = 2,
                                '28-32' = 3,
                                '33-37' = 4,
                                '38-42' = 5,
                                '43-47' = 6,
                                '48 or older' = 7)

# Create polynomial terms

poly.mat <- poly(x = recidivism$age, degree=6)
head(poly.mat)

# Append them to the original data

recidivism$age_poly1 <- poly.mat[,1]
recidivism$age_poly2 <- poly.mat[,2]
recidivism$age_poly3 <- poly.mat[,3]
recidivism$age_poly4 <- poly.mat[,4]
recidivism$age_poly5 <- poly.mat[,5]
recidivism$age_poly6 <- poly.mat[,6]

head(recidivism[,c('Age_at_Release','age','age_poly1','age_poly2',
                   'age_poly3','age_poly4','age_poly5','age_poly6')],10)

```

Notice that the values assigned to each category are different than the ones you see above, because they are rescaled such that polynomial terms have a unit length (sum of squared values equal to 1) and they are independent of each other (dot product is zero).

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

# Length of each polynomial term (sum of square values)

colSums(recidivism[,c('age_poly1','age_poly2','age_poly3','age_poly4','age_poly5','age_poly6')]^2)

# The dot product is zero for each pair of 6 terms, see for a few examples

sum(recidivism[,c('age_poly1')]*recidivism[,c('age_poly2')])
sum(recidivism[,c('age_poly1')]*recidivism[,c('age_poly3')])
sum(recidivism[,c('age_poly4')]*recidivism[,c('age_poly6')])

```


***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

There are other ways of encoding nominal and ordinal variables (e.g., Helmert contrasts), or one can come up with their own set of contrast values. When the goal of analysis is inference and you run analysis to respond to a specific research question, your research question typically dictates the type of encoding to use. You choose a coding scheme that provides you the most interpretable coefficients to respond to your research question. 

On the other hand, when the goal of analysis is prediction, how you encode your categorical variable does not make much difference. In fact, they provide very similar predictions. Below, I provide an example using Age_at_Release variable to predict the outcome using different coding schemes and report the average squared error of predictions from a logistic regression model. 

<center>

| Encoding             | Average Squared Error|
|----------------------|:--------------------:|
| Intercept-Only (NULL)|0.1885789             |                      
| Dummy Variables      |0.1861276             | 
| Label Encoding       |0.1861888             | 
| Polynomial Contrasts |0.1861276             |
| Helmert Contrasts    |0.1861276             | 

</center>

Notice that one-hot encoding, polynomial contrasts, and helmert contrasts have identical performance. In fact, they yield the exact same predicted value for observations. Moreover, a simple label encoding with a single constructed variable does (almost) as well as other encoding types with multiple constructed variables.  

</div>
***

# 3. Processing Cyclic Variables

There are sometimes variables that are cyclic by nature (e.g., months, days, hour), and a type of encoding that represents their cyclic nature may be the most meaningful way to represent them instead of numerical or categorical encoding. One way to achieve this is to create two new variables using a sine and cosine transformation as the following:

$$x_{1} = sin(\frac{2 \pi x}{max(x)}),$$
$$x_{2} = cos(\frac{2 \pi x}{max(x)}).$$

For instance, suppose one of the variables in a dataset is the day of the week. We can represent its cyclic nature using the two variables as defined the following. Once the corresponding coordinates are calculated for each day of the week, the single variable that represents days in the data can be replaced with these two variables representing their coordinates in a unit circle.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

d <- data.frame(days = c('Mon','Tue','Wed','Thu','Fri','Sat','Sun'),
                x = 1:7)

d$x1 <- sin((2*pi*d$x)/7)
d$x2 <- cos((2*pi*d$x)/7)

d
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=6,fig.height=6}

ggplot(data = d, aes(x=x1,y=x2))+
  geom_point(cex=3)+
  annotate("path",
   x=cos(seq(0,2*pi,length.out=100)),
   y=sin(seq(0,2*pi,length.out=100)))+
  theme_bw()+
  xlab('')+
  ylab('')+
  annotate("text", x = 0, y = 0.95, label = "Sun")+
  annotate("text", x = 0.72, y = 0.6, label = "Mon")+
  annotate("text", x = 0.9, y = -0.2, label = "Tue")+
  annotate("text", x = 0.39, y = -0.85, label = "Wed")+
  annotate("text", x = -0.39, y = -0.85, label = "Thu")+
  annotate("text", x = -.9, y = -0.2, label = "Fri")+
  annotate("text", x = -.72, y = 0.6, label = "Sat")
  
```


We can apply the same concept to any cyclic variable. Here is another example for the time of day.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

d <- data.frame(hour = 1:24)

d$x1 <- sin((2*pi*d$hour)/24)
d$x2 <- cos((2*pi*d$hour)/24)

d
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=6,fig.height=6}

ggplot(data = d, aes(x=x1,y=x2,label = 1:24))+
  geom_point(cex=3)+
  annotate("path",
   x=cos(seq(0,2*pi,length.out=100)),
   y=sin(seq(0,2*pi,length.out=100)))+
  theme_bw()+
  xlab('')+
  ylab('')+
  geom_text(nudge_y = c(rep(-0.05,6),rep(0.05,6),rep(0.05,6),rep(-0.05,6)), 
            nudge_x = c(rep(-0.02,6),rep(-0.02,6),rep(0.02,6),rep(0.02,6)))
  
```


# 4. Processing Continuous Variables

## 4.1 Centering and Scaling (Standardization)

Centering a variable is done by substracting the mean of the variable from every value of the variable. This ensures that the mean of the centered variable is equal to zero. Scaling a variable is by dividing every value of variable by its standard deviation. When centering and scaling are both applied, this is called standardizing a variable. When we standardize a variable, we make sure that its mean is equal to zero and variance is equal to 1. Standardization may be important for certain types of models (e.g., K-nearest neighbor, support vector machines, penalized regression).

Below is an example from the Recidivism dataset using the variable `Avg_Days_per_DrugTest`.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}
require(psych)

# Descriptive stats for the original variable

describe(recidivism$Avg_Days_per_DrugTest)

  # Center

  recidivism$Avg_Days_per_DrugTest2 <- recidivism$Avg_Days_per_DrugTest - mean(recidivism$Avg_Days_per_DrugTest,na.rm=TRUE)

  # Scale

  recidivism$Avg_Days_per_DrugTest2 <- recidivism$Avg_Days_per_DrugTest2/sd(recidivism$Avg_Days_per_DrugTest,na.rm=TRUE)

# Descriptive stats for the standardized variable
  
describe(recidivism$Avg_Days_per_DrugTest2)

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=10}

p1 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Original')

p2 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest2))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Standardized')

grid.arrange(p1,p2,nrow=1)
```

***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

Standardizing a variable only changes the first and second moments of a distribution (mean and variance); however, it doesn't change the third and fourth moments of a distribution (skewness and kurtosis). Notice that the skewness and kurtosis for both the original and the standardized variable are 3.64 and 18.24, respectively. We only change the mean to zero and variance to one by standardizing a variable.

</div>
***
## 4.2 Box-Cox transformation

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

require(MASS)

bx <- boxcox(Avg_Days_per_DrugTest ~ 1,data=recidivism,
             plotit=FALSE)

bx

which.max(bx$y)

l <- bx$x[which.max(bx$y)]

l

recidivism$Avg_Days_per_DrugTest_norm <- recidivism$Avg_Days_per_DrugTest^l

describe(recidivism$Avg_Days_per_DrugTest_norm)
```


```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=10}

p1 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Original')

p2 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest_norm))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Box-Cox Transformation')

grid.arrange(p1,p2,nrow=1)

```

***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

Apply Box-Cox first, and then standardize.
</div>
***

## 4.3 Yeo-Johnson transformation

## 4.4. Logit Transformation

## 4.5 Basis Expansions and Splines

## 4.6 Principal Component Analysis

# Handling Missing Data

# Data Leakage 

# Processing Text Data

# All-in-one using the `recipes` package 

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show'}

#recidivism$age <- dplyr::recode(recidivism$Age_at_Release,
#                                    '18-22' = 1,
#                                    '23-27' = 2,
#                                    '28-32' = 3,
#                                    '33-37' = 4,
#                                    '38-42' = 5,
#                                    '43-47' = 6,
#                                    '48 or older' = 7)

#recidivism$out <- ifelse(recidivism$Recidivism_Arrest_Year2=='true',1,0)

#recidivism2 <- recidivism[,c('age','out','Prison_Offense','Avg_Days_per_DrugTest')]

#recidivism2$age <- as.integer(recidivism2$age)

#recidivism2 <- as_tibble(recidivism2)
#recidivism2 <- recidivism2[1:100,]

#ddd <- tibble(x = 1:5)

#recipe(~ x, data = ddd) %>%
#  step_poly(x, degree = 4) %>%
#  prep() %>%
#  juice()


#recipe(out ~ ., data = recidivism2) %>%
#  step_poly(age, degree = 6) %>%
#  prep() %>%
#  juice


#blueprint <- recipe(out ~ ., data=recidivism2) %>% 
#  step_poly(age,degree=6) %>%
#  prep

#prepare <- prep(blueprint, training = recidivism2)
#prepare

#baked_train <- bake(prepare, new_data = recidivism2)
#baked_train
```










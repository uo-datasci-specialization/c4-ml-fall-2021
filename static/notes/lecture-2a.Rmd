---
title: Data Pre-processing (Feature Engineering)
subtitle: Applied Machine Learning for Educational Data Science
author:
  name: Cengiz Zopluoglu
  affiliation: University of Oregon | EDLD 654
date: 08/23/2021 ## Or "Lecture no."
output: 
  html_document:
    keep_md: false
    theme: journal
    highlight: haddock
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    extra_dependencies: ["amssymb","animate"]
    keep_tex: false ## Change to true if want keep intermediate .tex file
    toc: true
    toc_depth: 3
    dev: cairo_pdf
always_allow_html: true
urlcolor: blue
mainfont: cochineal
sansfont: Fira Sans
monofont: Fira Code ## Although, see: https://tex.stackexchange.com/q/294362

## Automatically knit to both formats:
knit: (function(inputFile, encoding) {
 rmarkdown::render(inputFile, encoding = encoding, 
 output_format = 'all') 
 })
---



```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position=c('top','right'))
```

`r paste('[Updated:',format(Sys.time(),'%a, %b %d, %Y - %H:%M:%S'),']')`

<style>

.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {
    z-index: 2;
    color: #fff;
    background-color: #FC4445;
    border-color: #97CAEF;
}

#infobox {
  padding: 1em 1em 1em 4em;
  margin-bottom: 10px;
  border: 2px solid black;
  border-radius: 10px;
  background: #E6F6DC 5px center/3em no-repeat;
}

</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = "",fig.align='center')
require(here)
require(ggplot2)
require(plot3D)
require(kableExtra)
require(knitr)
require(giski)
require(magick)
require(gridExtra)
options(scipen=99)

# Resources:

  # http://www.feat.engineering/index.html
  # https://bradleyboehmke.github.io/HOML/engineering.html
  # Applied Predictive Modeling, Chapter 3

```

# 1. Scales of Measurement and Types of Variables

It is important to understand the nature of variables and how they were measured and represented in a dataset. In social sciences, in particular psychology, there is a methodological consensus about the framework provided by [Stevens (1946)](https://www.jstor.org/stable/1671815), also see [Michell (2002)](https://doi.org/10.1080/00049530210001706563) for an in-depth discussion. According to Stevens' definition, there are four levels of measurement: nominal, ordinal, interval, and ratio. Whether a variable is considered having a nominal, ordinal, interval, or ratio scale depends on the character of the empirical operations performed while constructing the variable. 

- Nominal scale: Variables with a nominal scale cannot be be meaningfully added, subtracted, divided, or multiplied. Also, there is no hierarchical order among the assigned values. Most variables that contains labels for individual observations can be considered as nominal, e.g., hair color, city, state, ethnicity.

- Ordinal scale: Variables with an ordinal scale also represent labels; however, there is a meaningful hierarchy among the assigned values. For instance, if a variable is coded as Low, Medium, and High, they are simply labels but we know that High represents something more than Medium, and Medium represents something higher than Low (High > Medium > Low). On the other side, the distance between the assigned values do not necessarily represent the same amount of difference. Other examples of variables that can be considered as ordinal are letter grades (A-F), scores from likert type items (Strongly agree, agree, disagree, strongly disagree), education status(high school, college, master's, PhD), cancer stage (stage1, stage2, stage3), order of finish in a competition (1st, 2nd, 3rd).

- Interval scale: Variables with an ordinal scale represents quantities with equal measurement units but they don't have an absolute zero point. For instance, a typical example of an interval scale is temperature measured on the Fahrenheit scale. The difference between 20F and 30F is the same difference as the difference between 60F and 70F. However, 0F does not indicate no heat.

- Ratio scale: Variables with a ratio scale represents quantities with equal measurement units and have an absolute zero. Due to the nature of the existence of absolute zero point that represent 'nothing', ratio of measurements are also meaningful. Typical examples are height, mass, distance, length.

Below table provides a summary of properties for each scale.

|          | Indicating Difference | Indicating Direction of Difference | Indicating Amount of Difference | Has absolute zero |
|----------|:---------------------:|:----------------------------------:|:-------------------------------:|:-----------------:|
| Nominal  | X                      |                                    |                                 |                   |
| Ordinal  | X                     | X                                  |                                 |                   |
| Interval | X                     | X                                  | X                               |                   |
| Ratio    | X                     | X                                  | X                               | X                 |

In this class, we classify the variables in two types: **Categorical** and **Continuous**. The variables with a nominal or ordinal scale are considered as **Categorical** and the variables with an interval or ratio scale are considered as **Continuous**.


***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

In the following sections, you will see some R code to process different types of variables using the base R functions to introduce certain types of coding schemes. At the end, I will introduce the `recipes` package to provide a more complete picture of how to do all these different types of encoding in a more efficient manner for this specific dataset.

</div>
***

# 2. Processing Categorical Variables

When there are categorical predictors in a dataset, it is important to translate them into numerical codes. When encoding categorical predictors, we try to preserve as much information as possible from its labels. Therefore, different strategies may be used for categorical variables with different ordinal scales.

## 2.1 One-hot encoding (Dummy Variables)

A dummy variable is a synthetic variable with two outcomes (0 and 1) to represent a group membership. When there is a nominal variable with *N* levels, it is typical to create *N* dummy variables to represent the information in the nominal variable. Each dummy variable represents a membership to one of the levels in the nominal variable. These dummy variables can be used as features in predictive models.

In its simplest case, consider variable `Race` in the Recidivism dataset with two levels: Black and White. We can create two dummy variables such that the first dummy variable represents whether or not an individual is Black and the second dummy variable represents whether or not the individual is White.


|        | Dummy Variable 1 | Dummy Variable 2 |
|--------|:----------------:|:----------------:|
| Black  |     1            |       0
| White  |     0            |       1          |


```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

recidivism <- read.csv('https://raw.githubusercontent.com/uo-datasci-specialization/c4-ml-fall-2021/main/data/recidivism_y1 removed.csv',header=TRUE)

table(recidivism$Race)

recidivism$black <- ifelse(recidivism$Race=='BLACK',1,0)
recidivism$white <- ifelse(recidivism$Race=='WHITE',1,0)

head(recidivism[,c('Race','black','white')])

table(recidivism$black)
table(recidivism$white)
```

Let's consider another example from the Recidivism dataset. Variable `Prison_Offense` has five categories: Violent/Sex, Violent/Non-Sex, Property, Drug, Other. We can create five dummy variables using the following coding scheme. 

|                  | Dummy Variable 1 | Dummy Variable 2 | Dummy Variable 3 | Dummy Variable 4 | Dummy Variable 5 |
|------------------|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:|
| Violent/Sex      |     1            |       0          |     0            |     0            |     0            |
| Violent/Non-Sex  |     0            |       1          |     0            |     0            |     0            |
| Property         |     0            |     0            |     1            |     0            |     0            |
| Drug             |     0            |     0            |     0            |     1            |     0            |
| Other            |     0            |     0            |     0            |     0            |     1            |

Note that `Prison_Offence` is missing for a number of observations. You can fill-in the missing values prior to creating dummy variables using one of the methods we will discuss later. Alternatively, we can define Missing as the sixth category to preserve that information.

|                  | Dummy Variable 1 | Dummy Variable 2 | Dummy Variable 3 | Dummy Variable 4 | Dummy Variable 5 |Dummy Variable 6 |
|------------------|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:|:----------------:
| Violent/Sex      |     1            |       0          |     0            |     0            |     0            |    0            |
| Violent/Non-Sex  |     0            |       1          |     0            |     0            |     0            |    0            |
| Property         |     0            |     0            |     1            |     0            |     0            |    0            |
| Drug             |     0            |     0            |     0            |     1            |     0            |    0            |
| Other            |     0            |     0            |     0            |     0            |     1            |    0            |
| Missing          |     0            |     0            |     0            |     0            |     0            |    1            |


```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

table(recidivism$Prison_Offense)
names(table(recidivism$Prison_Offense))

recidivism$off_viosex   <- ifelse(recidivism$Prison_Offense=='Violent/Sex',1,0)
recidivism$off_vionosex <- ifelse(recidivism$Prison_Offense=='Violent/Non-Sex',1,0)
recidivism$off_property <- ifelse(recidivism$Prison_Offense=='Property',1,0)
recidivism$off_drug     <- ifelse(recidivism$Prison_Offense=='Drug',1,0)
recidivism$off_other    <- ifelse(recidivism$Prison_Offense=='Other',1,0)
recidivism$off_missing  <- ifelse(recidivism$Prison_Offense=='',1,0)

head(recidivism[,c('Prison_Offense','off_viosex','off_vionosex','off_property','off_drug','off_other','off_missing')],10)

```

In some cases, when you have geographical location with a reasonable number of categories (e.g., counties or cities in a state, schools in a district), you can also create dummy variables to represent this information. In our case, the Recidivism dataset has a variable called `Residence_PUMA` indicating [Public Use Microdata Area (PUMA)](https://www.census.gov/programs-surveys/geography/guidance/geo-areas/pumas.html) for the residence address at the time individual was released. There is a total of 25 unique codes (1-25) for this variable; however, these numbers are just labels. So, one can create 25 different dummy variables to represent 25 different PUMAs.

***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

When you fit a typical regression model without regularizaton using ordinary least-squares (OLS), a typical practice is to drop a dummy variable for one of the levels. So, for instance, if there are *N* levels for a nominal variable, you only have to create *(N-1)* dummy variables, as the Nth one has redundant information. The information regarding to the excluded category is represented in the intercept term. It creates a problem when you put all *N* dummy variables into the model, because the OLS procedure tries to invert a singular matrix and you will likely get an error message. 

On the other hand, this is not an issue when you fit a regularized regression model, which will be the case in this class. Therefore, you do not need to drop one of the dummy variables and can include all of them in the analysis. In fact, it may be beneficial to keep the dummy variables for all categories in the model when regularization is used in regression. Otherwise, the model may produce different predictions depending on which category is excluded.

</div>
***

## 2.2. Label encoding

When the variable of interest is ordinal and there is a hierarchy among the levels, we can still use one-hot encoding to create a set of dummy variables to represent the information in the ordinal variable. However, dummy variables will not provide any information regarding the hierarchy among categories. 

For instance, consider the variable `Age_At_Release` in the Recidivism dataset. It is coded as 7 different age intervals in the dataset: 18-22, 23-27, 28-32, 33-37, 38-42, 43-47, 48 or older. One can create 7 dummy variables to represent each category in this variable. Alternatively, one can assign a numeric variable to each category that may represent the information in these categories. For instance, one can assign numbers from 1 to 7, respectively. Or, one can choose the midpoint of each interval to represent each category (e.g., 20,25,31,35,40,45,60).

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show', message=FALSE, warning=FALSE}

require(dplyr)
table(recidivism$Age_at_Release)

#?dplyr::recode
recidivism$age <- recode(recidivism$Age_at_Release,
                         '18-22' = 20,
                         '23-27' = 25,
                         '28-32' = 30,
                         '33-37' = 35,
                         '38-42' = 40,
                         '43-47' = 45,
                         '48 or older' = 60)

hist(recidivism$age,main='',xlab='Age at Release (Label Encoding)')
```

Another example would be the variable `Education Level`. It has three different levels: At least some college, High School Diploma, Less than HS diploma. One can create three dummy variables to represent each level. Alternatively, one can assign 1, 2, and 3, respectively. Or, one can assign a number for the approximate years of schooling for each level such as 9, 12, and 15.   

```{r, echo=TRUE,eval=knitr::is_html_output(),class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

table(recidivism$Education_Level)

recidivism$edu <- recode(recidivism$Education_Level,
                         'At least some college' = 14,
                         'High School Diploma'   = 12,
                         'Less than HS diploma'  = 8)

hist(recidivism$edu,main='',xlab='Education Level (Label Encoding)')
```

## 2.3. Polynomial Contrasts

Another way of encoding an ordinal variable is to use polynomial contrasts. The polynomial contrasts may be helpful if one wants to explore whether or not there is a linear, quadratic, cubic, etc. relationship between the predictor variable and outcome variable. You can use `stat::poly()` function in R to obtain the set of polynomial contrasts. If there are *N* levels in an ordinal variable, then you can get polynomials up to degree *N-1*. 

For instance, suppose you have an ordinal variable with three levels: Low, Medium, and High. Then, `stat::poly(x=1:3,degree=2)` will return the polynomial contrasts for the linear and quadratic terms. Notice that the input values for the `poly` function is a vector of numeric values that correspond to the levels in the ordinal variable, and the degree of polynomial terms requested. For this examle, it creates two sets of vectors to represent this ordinal variable. Note that the sum of the squares within each column is equal to 1, and the dot product of the contrast vectors is equal to 0. In other words, the polynomial terms represent a set of **orthonormal vectors**.

|        | Linear           | Quadratic        |
|--------|:----------------:|:----------------:|
| Low    |     -0.707       |       0.408      |
| Medium |       0          |       -0.816     |
| High   |     0.707        |       0.408      |

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

ctr <- poly(1:3,2)
ctr

sum(ctr[,1]^2)
sum(ctr[,2]^2)

sum(ctr[,1]*ctr[,2])

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

linear <- ggplot()+
  geom_point(aes(x=1:3,y=ctr[,1]),cex=3)+
  geom_line(aes(x=1:3,y=ctr[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Linear Term')

quad <- ggplot()+
  geom_point(aes(x=1:3,y=ctr[,2]),cex=3)+
  geom_line(aes(x=1:3,y=ctr[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Quadratic Term')

grid.arrange(linear,quad,nrow=1)
```

If we consider the variable `Age_At_Release` with 7 different levels, then we can have polynomial terms up to the 6th degree. 

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

ctr <- poly(1:7,6)
ctr
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

linear <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,1]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Linear Term')

quad <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,2]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Quadratic Term')

cubic <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,3]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,3]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Cubic Term')

fourth <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,4]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,4]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('4th Degree Term')

fifth <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,5]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,5]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('5th Degree Term')


sixth <- ggplot()+
  geom_point(aes(x=1:7,y=ctr[,6]),cex=3)+
  geom_line(aes(x=1:7,y=ctr[,6]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('6th Degree Term')


grid.arrange(linear,quad,cubic,fourth,fifth,sixth,nrow=3,ncol=2)
```

When we apply this to a variable in the dataset, these columns are rescaled such that they are orthonormal vectors. See below for an example:

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

# First, recode the Age_at_Release so that its levels are represented by numbers
# poly() doesn't work with character vectors

recidivism$age <- dplyr::recode(recidivism$Age_at_Release,
                                '18-22' = 1,
                                '23-27' = 2,
                                '28-32' = 3,
                                '33-37' = 4,
                                '38-42' = 5,
                                '43-47' = 6,
                                '48 or older' = 7)

# Create polynomial terms

poly.mat <- poly(x = recidivism$age, degree=6)
head(poly.mat)

# Append them to the original data

recidivism$age_poly1 <- poly.mat[,1]
recidivism$age_poly2 <- poly.mat[,2]
recidivism$age_poly3 <- poly.mat[,3]
recidivism$age_poly4 <- poly.mat[,4]
recidivism$age_poly5 <- poly.mat[,5]
recidivism$age_poly6 <- poly.mat[,6]

head(recidivism[,c('Age_at_Release','age','age_poly1','age_poly2',
                   'age_poly3','age_poly4','age_poly5','age_poly6')],10)

```

Notice that the values assigned to each category are different than the ones you see above, because they are rescaled such that polynomial terms have a unit length (sum of squared values equal to 1) and they are independent of each other (dot product is zero).

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

# Length of each polynomial term (sum of square values)

colSums(recidivism[,c('age_poly1','age_poly2','age_poly3','age_poly4','age_poly5','age_poly6')]^2)

# The dot product is zero for each pair of 6 terms, see for a few examples

sum(recidivism[,c('age_poly1')]*recidivism[,c('age_poly2')])
sum(recidivism[,c('age_poly1')]*recidivism[,c('age_poly3')])
sum(recidivism[,c('age_poly4')]*recidivism[,c('age_poly6')])

```


***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

There are other ways of encoding nominal and ordinal variables (e.g., Helmert contrasts), or one can come up with their own set of contrast values. When the goal of analysis is inference and you run analysis to respond to a specific research question, your research question typically dictates the type of encoding to use. You choose a coding scheme that provides you the most interpretable coefficients to respond to your research question. 

On the other hand, when the goal of analysis is prediction, how you encode your categorical variable does not make much difference. In fact, they provide very similar predictions. Below, I provide an example using Age_at_Release variable to predict the outcome using different coding schemes and report the average squared error of predictions from a logistic regression model. 

<center>

| Encoding             | Average Squared Error|
|----------------------|:--------------------:|
| Intercept-Only (NULL)|0.1885789             |                      
| Dummy Variables      |0.1861276             | 
| Label Encoding       |0.1861888             | 
| Polynomial Contrasts |0.1861276             |
| Helmert Contrasts    |0.1861276             | 

</center>

Notice that one-hot encoding, polynomial contrasts, and helmert contrasts have identical performance. In fact, they yield the exact same predicted value for observations. Moreover, a simple label encoding with a single constructed variable does (almost) as well as other encoding types with multiple constructed variables.  

</div>
***

# 3. Processing Cyclic Variables

There are sometimes variables that are cyclic by nature (e.g., months, days, hour), and a type of encoding that represents their cyclic nature may be the most meaningful way to represent them instead of numerical or categorical encoding. One way to achieve this is to create two new variables using a sine and cosine transformation as the following:

$$x_{1} = sin(\frac{2 \pi x}{max(x)}),$$
$$x_{2} = cos(\frac{2 \pi x}{max(x)}).$$

For instance, suppose one of the variables in a dataset is the day of the week. We can represent its cyclic nature using the two variables as defined the following. Once the corresponding coordinates are calculated for each day of the week, the single variable that represents days in the data can be replaced with these two variables representing their coordinates in a unit circle.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

d <- data.frame(days = c('Mon','Tue','Wed','Thu','Fri','Sat','Sun'),
                x = 1:7)

d$x1 <- sin((2*pi*d$x)/7)
d$x2 <- cos((2*pi*d$x)/7)

d
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=6,fig.height=6}

ggplot(data = d, aes(x=x1,y=x2))+
  geom_point(cex=3)+
  annotate("path",
   x=cos(seq(0,2*pi,length.out=100)),
   y=sin(seq(0,2*pi,length.out=100)))+
  theme_bw()+
  xlab('')+
  ylab('')+
  annotate("text", x = 0, y = 0.95, label = "Sun")+
  annotate("text", x = 0.72, y = 0.6, label = "Mon")+
  annotate("text", x = 0.9, y = -0.2, label = "Tue")+
  annotate("text", x = 0.39, y = -0.85, label = "Wed")+
  annotate("text", x = -0.39, y = -0.85, label = "Thu")+
  annotate("text", x = -.9, y = -0.2, label = "Fri")+
  annotate("text", x = -.72, y = 0.6, label = "Sat")
  
```


We can apply the same concept to any cyclic variable. Here is another example for the time of day.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

d <- data.frame(hour = 1:24)

d$x1 <- sin((2*pi*d$hour)/24)
d$x2 <- cos((2*pi*d$hour)/24)

d
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=6,fig.height=6}

ggplot(data = d, aes(x=x1,y=x2,label = 1:24))+
  geom_point(cex=3)+
  annotate("path",
   x=cos(seq(0,2*pi,length.out=100)),
   y=sin(seq(0,2*pi,length.out=100)))+
  theme_bw()+
  xlab('')+
  ylab('')+
  geom_text(nudge_y = c(rep(-0.05,6),rep(0.05,6),rep(0.05,6),rep(-0.05,6)), 
            nudge_x = c(rep(-0.02,6),rep(-0.02,6),rep(0.02,6),rep(0.02,6)))
  
```


# 4. Processing Continuous Variables

## 4.1. Centering and Scaling (Standardization)

Centering a variable is done by substracting the mean of the variable from every value of the variable. This ensures that the mean of the centered variable is equal to zero. Scaling a variable is by dividing every value of variable by its standard deviation. When centering and scaling are both applied, this is called standardizing a variable. When we standardize a variable, we make sure that its mean is equal to zero and variance is equal to 1. Standardization may be important for certain types of models (e.g., K-nearest neighbor, support vector machines, penalized regression).

Below is an example from the Recidivism dataset using the variable `Avg_Days_per_DrugTest`.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}
require(psych)

# Descriptive stats for the original variable

describe(recidivism$Avg_Days_per_DrugTest)

  # Center

  recidivism$Avg_Days_per_DrugTest2 <- recidivism$Avg_Days_per_DrugTest - mean(recidivism$Avg_Days_per_DrugTest,na.rm=TRUE)

  # Scale

  recidivism$Avg_Days_per_DrugTest2 <- recidivism$Avg_Days_per_DrugTest2/sd(recidivism$Avg_Days_per_DrugTest,na.rm=TRUE)

# Descriptive stats for the standardized variable
  
describe(recidivism$Avg_Days_per_DrugTest2)

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=10}

p1 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Original')

p2 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest2))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Standardized')

grid.arrange(p1,p2,nrow=1)
```

***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

Standardizing a variable only changes the first and second moments of a distribution (mean and variance); however, it doesn't change the third and fourth moments of a distribution (skewness and kurtosis). Notice that the skewness and kurtosis for both the original and the standardized variable are 3.64 and 18.24, respectively. We only change the mean to zero and variance to one by standardizing a variable.

</div>
***
## 4.2. Box-Cox transformation

Variables with extreme skewness and kurtosis may deteriorate the model performance for certain types of models. Therefore, it may sometimes be useful to transform a variable with extreme skewness and kurtosis such that its distribution approximates to a normal distribution. Box-Cox transformation is a method to find an optimal parameter of $\lambda$ to apply the following transformation:

$$y^{(\lambda)}=\left\{\begin{matrix}
\frac{y^{\lambda}-1}{\lambda} & , \lambda \neq 0 \\
 & \\ 
ln(y) & , \lambda = 0 
\end{matrix}\right.$$  

Below is an example of transforming the `Avg_Days_per_DrugTest` variable using the `boxcox` function from the `bestNormalize` package. Notice that the skewness and the kurtosis for the transformed variable are 0 and -0.02, respectively.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

require(bestNormalize)

fit <- boxcox(recidivism$Avg_Days_per_DrugTest,standardize=FALSE)
fit

recidivism$Avg_Days_per_DrugTest_norm <- predict(fit)
 
describe(recidivism$Avg_Days_per_DrugTest_norm)
```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=10}

p1 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Original')

p2 <- ggplot(data = recidivism, aes(x=Avg_Days_per_DrugTest_norm))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Box-Cox Transformation')

grid.arrange(p1,p2,nrow=1)

```

***
<div id="infobox">

<center style="color:black;"> **NOTE** </center>

Box-Cox transformation can be used only for variables with positive values. Therefore, it is a good idea to first implement the Box-Cox transformation, and then standardize a variable if both procedures will be applied to a variable. If there is a variable with negative values or a mix of both positive and negative values, the Yeo-Johnson transformation is available as an extension of the Box-Cox transformation. See [this link](https://www.stat.umn.edu/arc/yjpower.pdf) for more information. The function `yeojohnson` is available in the `bestNormalizer` package to implement the Yeo-Johnson transformation (See, [?bestNormalizer::yeojohnson](https://rdrr.io/cran/bestNormalize/man/yeojohnson.html)).
</div>
***

## 4.3. Logit Transformation

When a variable is a proportion bounded between 0 and 1, the logit transformation can be applied such that

$$\pi^{*} = ln(\frac{\pi}{1-\pi}),$$
where $\pi$ represents a proportion. This may be particularly useful when your outcome variable is a proportion bounded between 0 and 1. When a linear model is used to model an outcome bounded between 0 and 1, the model predictions may exceed the reasonable range of values (predictions equal to less than zero or greater than one). Logit transformation scales variables such that the range of values becomes $-\infty$ and $\infty$ on the logit scale. One can build a model to predict logit ($\pi^*$) instead of proportion ($\pi$), and then ensure that the model predictions are bounded between 0 and 1 on the original proportion scale after a simple reverse operation for predicted values. 

$$\pi = \frac{e^{\pi^*}}{1+e^{\pi^*}} $$
One caveat of using logit transformation is that it is not defined for 0 and 1. So, when you have values in the dataset exactly equal to 0 or 1, logit transformation will return either $-\infty$ and $\infty$. In these situations, we may add or substract a very tiny constant (e.g., .0001) to force the transformation to return a numerical value. 

$$\pi^{*} = ln(\frac{\pi}{1-\pi}) = ln(\frac{0}{1-0}) = -\infty$$
$$\pi^{*} = ln(\frac{\pi}{1-\pi}) = ln(\frac{1}{1-1}) = \infty$$
Below is an example of logit transformation for the variable `DrugTests_THC_Positive` in the dataset. There is a large amount of zeros in this variable, and some ones. First, I change the values in the dataset such that all zeros become 0.0001 and all ones become 0.9999. Then, I apply the logit transformation. Notice that the distribution looks more symmetric except the extreme values.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

recidivism$DrugTests_THC_Positive <- ifelse(recidivism$DrugTests_THC_Positive==0,
                                            .0001,
                                            recidivism$DrugTests_THC_Positive)

recidivism$DrugTests_THC_Positive <- ifelse(recidivism$DrugTests_THC_Positive==1,
                                            .9999,
                                            recidivism$DrugTests_THC_Positive)

recidivism$DrugTests_THC_Positive2 <- log(recidivism$DrugTests_THC_Positive/(1-recidivism$DrugTests_THC_Positive))

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE,fig.width=10}

p1 <- ggplot(data = recidivism, aes(x=DrugTests_THC_Positive))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Original')

p2 <- ggplot(data = recidivism, aes(x=DrugTests_THC_Positive2))+
  geom_histogram(col='white')+
  theme_bw()+
  xlab('')+
  ylab('')+
  ggtitle('Logit Transformation')

grid.arrange(p1,p2,nrow=1)

```

## 4.4. Basis Expansions

Basis expansions are useful to address nonlinearity between a predictor variable and outcome variable. Using the basis expansions, one can create a set of feature variables using a nonlinear function of a variable *x*, $\phi(x)$. One simply replaces the original variable *x* with the new variables obtained from $\phi(x)$. For continuous predictors, the most commonly used expansions are polynomial basis expansions. The nth degree polynomial basis expansion can be represented by

$$\phi(x) = \beta_1x + \beta_2x^2 + \beta_3x^3 + ... + \beta_nx^n .$$
Suppose we have a variable *x* with values from 1 to 10. The third degree polynomial basis expansion (cubic basis expansion) can be found using the `poly` function as the following.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

set.seed(654)

x <- rnorm(100,0,1)

head(x)

head(poly(x,degree=3))

```

So, one can use these three new variables representing a linear, quadratic, and cubic trend in our prediction model instead of the original variable *x*. See below the relationship between the original variable *x* and the new polynomial features to replace it. 

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

x1 <- poly(x,degree=3)

linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('Linear Term')+
  ggtitle('Linear Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('Quadratic Term')+
  ggtitle('Quadratic Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('Cubic Term')+
  ggtitle('Cubic Term')

grid.arrange(linear,quad,cubic,nrow=1,ncol=3)
```

For continuous predictors, there is no limit for the degree of polynomial. The higher the degree of polynomial, the more flexible the model becomes, and there is a higher chance of overfitting. Typically, polynomial terms up to the 3rd or 4th degree are more than enough.

One drawback of the polynomial basis expansions is their non-locality. In other words, the value for a polynomial term at $x_0$ depends on data values far from $x_0$. This may lead unstable behavior at the edge of the distribution of variable *x*. Therefore, polynomial splines may provide a better representation. In polynomial splines, the range of variable *x* is divided into multiple regions and a separate polynomial piece is created within each region. The points that divide the regions are called *knots*. One particular class of basis functions that represent polynomial splines are called B-splines that can be and can be obtained using the `bs` function from the `splines` package. The number of new features to be created is equal to the sum of the number of knots and the degree of polynomial. 

Suppose one wants to create B-splines with the first degree polynomial and a single knot ($\tau_1$). The basis function can be written as

$$\phi(x) = \beta_0 + \beta_1x + \beta_2(x-\tau_1).$$
For instance, `bs(x,degree=1,knot=0,intercept=TRUE)` will return a matrix with three columns representing the basis expansions of a first degree polynomial spline with a single knot at 0, $\tau=0$. 

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

require(splines)

head(bs(x,degree=1,knot=0,intercept=TRUE))

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

x1 <- bs(x,degree=1,knot=0,intercept=TRUE)

linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The First Term')+
  ggtitle('The First Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Second Term')+
  ggtitle('The Second Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Third Term')+
  ggtitle('The Third Term')

grid.arrange(linear,quad,cubic,nrow=1,ncol=3)
```

Instead of a single knot, one can request the basis expansions of a first degree polynomial spline with two knots, $\tau_1$ and $\tau_2$. Then the basis function can be written as

$$\phi(x) = \beta_0 + \beta_1x + \beta_2(x-\tau_1) + \beta_3(x-\tau_2),$$
and `bs(x,degree=1,knot=c(-1,1),intercept=TRUE)` will return a matrix with four columns representing the basis expansions of a first degree polynomial spline with two knots at -1 and 1, $\tau_1=-1$ and $\tau_2=1$ . 

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

head(bs(x,degree=1,knot=c(-1,1),intercept=TRUE))

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

x1 <- bs(x,degree=1,knot=c(-1,1),intercept=TRUE)

linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The First Term')+
  ggtitle('The First Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Second Term')+
  ggtitle('The Second Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Third Term')+
  ggtitle('The Third Term')

fourth <- ggplot()+
  geom_point(aes(x=x,y=x1[,4]),cex=1)+
  geom_line(aes(x=x,y=x1[,4]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fourth Term')+
  ggtitle('The Fourth Term')

grid.arrange(linear,quad,cubic,fourth,nrow=1,ncol=4)
```

A cubic spline with three knots is typically enough for most practical applications. The basis function can be written as

$$\phi(x) = \beta_0 + \beta_1x + \beta_2x^2 + \beta_3x^3 + \beta_4(x-\tau_1)^3 + \beta_5(x-\tau_2)^3 + \beta_6(x-\tau_3)^3 ,$$
and `bs(x,degree=3,knot=c(-1,0,1),intercept=TRUE)` will return a matrix with seven columns representing the basis expansions of cubic spline with three knots at -1, 0, and 1.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

head(bs(x,degree=3,knot=c(-1,0,1),intercept=TRUE))

```


```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

x1 <- bs(x,degree=3,knot=c(-1,0,1),intercept=TRUE)


linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The First Term')+
  ggtitle('The First Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Second Term')+
  ggtitle('The Second Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Third Term')+
  ggtitle('The Third Term')


fourth <- ggplot()+
  geom_point(aes(x=x,y=x1[,4]),cex=1)+
  geom_line(aes(x=x,y=x1[,4]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fourth Term')+
  ggtitle('The Fourth Term')

fifth <- ggplot()+
  geom_point(aes(x=x,y=x1[,5]),cex=1)+
  geom_line(aes(x=x,y=x1[,5]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fifth Term')+
  ggtitle('The Fifth Term')

sixth <- ggplot()+
  geom_point(aes(x=x,y=x1[,6]),cex=1)+
  geom_line(aes(x=x,y=x1[,6]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Sixth Term')+
  ggtitle('The Sixth Term')

seventh <- ggplot()+
  geom_point(aes(x=x,y=x1[,7]),cex=1)+
  geom_line(aes(x=x,y=x1[,7]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Seventh Term') +
  ggtitle('The Seventh Term')

grid.arrange(linear,quad,cubic,fourth, fifth, sixth,seventh,nrow=2,ncol=4)
```

Another class of basis functions that represent polynomial splines is Natural Splines. Natural splines are similar to B-splines with additional constraints that they are linear in the tails of the boundary knots, $(-\infty,\tau_1]$ and $(\tau_n,\infty]$. The natural splines may provide better behavior at the boundaries of the variable. Below is an example how to request natural cubic splines basis functions with three knots at -1, 0, and 1 using the `ns` function from the `splines` package.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

head(ns(x,knot=c(-1,0,1),intercept=TRUE))

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

x1 <- ns(x,knot=c(-1,0,1),intercept=TRUE)


linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The First Term')+
  ggtitle('The First Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Second Term')+
  ggtitle('The Second Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Third Term')+
  ggtitle('The Third Term')

fourth <- ggplot()+
  geom_point(aes(x=x,y=x1[,4]),cex=1)+
  geom_line(aes(x=x,y=x1[,4]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fourth Term')+
  ggtitle('The Fourth Term')

fifth <- ggplot()+
  geom_point(aes(x=x,y=x1[,5]),cex=1)+
  geom_line(aes(x=x,y=x1[,5]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fifth Term')+
  ggtitle('The Fifth Term')

grid.arrange(linear,quad,cubic,fourth, fifth,nrow=2,ncol=3)
```


Below, there is an example of cubic basis expansion of a continuous predictor `Jobs_Per_Year` using B-splines and Natural Splines at three knot points. I choose the knot locations such that they correspond to the 25th, 50th, and 75th percentile in the distribution of this variable. 

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

knots <- quantile(recidivism$Jobs_Per_Year,probs = c(.25,.5,.75),na.rm=TRUE)

head(bs(recidivism$Jobs_Per_Year,degree=3,knots = knots,intercept=TRUE))

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

knots <- quantile(recidivism$Jobs_Per_Year,probs = c(.25,.5,.75),na.rm=TRUE)

x  <- recidivism$Jobs_Per_Year
x1 <- bs(recidivism$Jobs_Per_Year,
         degree=3,
         knots = knots,
         intercept=TRUE)

linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The First Term')+
  ggtitle('The First Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Second Term')+
  ggtitle('The Second Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Third Term')+
  ggtitle('The Third Term')


fourth <- ggplot()+
  geom_point(aes(x=x,y=x1[,4]),cex=1)+
  geom_line(aes(x=x,y=x1[,4]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fourth Term')+
  ggtitle('The Fourth Term')

fifth <- ggplot()+
  geom_point(aes(x=x,y=x1[,5]),cex=1)+
  geom_line(aes(x=x,y=x1[,5]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fifth Term')+
  ggtitle('The Fifth Term')

sixth <- ggplot()+
  geom_point(aes(x=x,y=x1[,6]),cex=1)+
  geom_line(aes(x=x,y=x1[,6]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Sixth Term')+
  ggtitle('The Sixth Term')

seventh <- ggplot()+
  geom_point(aes(x=x,y=x1[,7]),cex=1)+
  geom_line(aes(x=x,y=x1[,7]),lty=2)+
  ylim(c(0,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Seventh Term') +
  ggtitle('The Seventh Term')

grid.arrange(linear,quad,cubic,fourth, fifth, sixth,seventh,nrow=2,ncol=4)
```

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

knots <- quantile(recidivism$Jobs_Per_Year,probs = c(.25,.5,.75),na.rm=TRUE)

head(ns(recidivism$Jobs_Per_Year,knots = knots,intercept=TRUE))

```

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

knots <- quantile(recidivism$Jobs_Per_Year,probs = c(.25,.5,.75),na.rm=TRUE)

x  <- recidivism$Jobs_Per_Year
x1 <- ns(recidivism$Jobs_Per_Year,
         knots = knots,
         intercept=TRUE)

linear <- ggplot()+
  geom_point(aes(x=x,y=x1[,1]),cex=1)+
  geom_line(aes(x=x,y=x1[,1]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The First Term')+
  ggtitle('The First Term')

quad <- ggplot()+
  geom_point(aes(x=x,y=x1[,2]),cex=1)+
  geom_line(aes(x=x,y=x1[,2]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Second Term')+
  ggtitle('The Second Term')

cubic <- ggplot()+
  geom_point(aes(x=x,y=x1[,3]),cex=1)+
  geom_line(aes(x=x,y=x1[,3]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Third Term')+
  ggtitle('The Third Term')


fourth <- ggplot()+
  geom_point(aes(x=x,y=x1[,4]),cex=1)+
  geom_line(aes(x=x,y=x1[,4]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fourth Term')+
  ggtitle('The Fourth Term')

fifth <- ggplot()+
  geom_point(aes(x=x,y=x1[,5]),cex=1)+
  geom_line(aes(x=x,y=x1[,5]),lty=2)+
  ylim(c(-1,1))+
  theme_bw()+
  xlab('X')+
  ylab('The Fifth Term')+
  ggtitle('The Fifth Term')

grid.arrange(linear,quad,cubic,fourth, fifth,nrow=2,ncol=3)
```

# 5. Handling Missing Data

Missing data deserves a course of its own. For a comprehensive review of how to handle and impute missing data. For certain types of models such as gradient boosting, missing data is not a problem, and one can leave them as is without any processing. On the other hand, some models such as regularized regression models require complete data and one have to deal with missing data before modeling data.

First, we can do a very preliminary analysis about the amount of missing data. In the below code, we compute the proportion of missing values for 48 predictor variables and the outcome variable in the dataset using the `finalfit` package.

```{r, echo=FALSE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

recidivism <- read.csv('https://raw.githubusercontent.com/uo-datasci-specialization/c4-ml-fall-2021/main/data/recidivism_y1 removed.csv',header=TRUE)
```

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

require(finalfit)

ff_glimpse(recidivism)$Continuous[,c('n','missing_percent')]


ff_glimpse(recidivism)$Categorical[,c('n','missing_percent')]

```

We will focus a few ideas about how to handle missing data.

## 5.1. Creating missing data indicator variables

For every variable, we can create a binary indicator variable to indicate missingess (0: not missing, 1: missing). This doesn't solve the missing data problem because we may still have to impute the missing values for modeling; however, the indicator variables about whether or not variables are missing may sometimes provide some information in predicting the outcome. If the missingness is not random and there is a systematic relationship between outcome and whether or not values are missing for a variable, then this may be some important information to bring into the model. For variables that doesn't have any missing value, this indicator variable would be meaningless. Therefore, one can remove them from any further consideration.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE, fig.width=10}

# The code below generates a separate corresponding matrix of the indicator 
# variables for missingness in the original data matrix

missing_indicator <- function(x){
  ifelse(is.na(x),1, 0)
}

recidivism_missing   <- apply(X       = recidivism, 
                               MARGIN = 2, 
                               FUN    = missing_indicator)


# eliminate the variables with no missingness

  # Calculate the variance
  
  variance.missing <- apply(X      = recidivism_missing,
                          MARGIN = 2,
                          FUN    = var)
  
  # Find variable with non-zero variance
  
  var.no.missing <- which(variance.missing!=0)
  
  # Selec the variables with non-zero variance
  
  recidivism_missing <- recidivism_missing[,var.no.missing]

head(recidivism_missing)
```

## 5.2. Imputation

A common approach to missing data is to impute missing values. In imputation, each predictor becomes an outcome of interest and then the remaining predictors are used to build an imputation model to predict the missing values. Below is a very naive example of how it would work if we have an outcome variable (Y) and three predictors (X1, X2, X3). First, missing values are estimated and replaced for each predictor using an imputation model, and then the main outcome of interest is predicted using the imputed X1, X2, and X3.

| Imputation Model |            |
|:----------------:|:----------:|
|      Outcome     | Predictors |
|        X1        |    X2,X3   |
|        X2        |    X1,X3   |
|        X3        |    X1,X2   |

| Prediction Model |            |
|:----------------:|:----------:|
|      Outcome     | Predictors |
|         Y        | X1, X2, X3 |

An imputation model can be something as simple as an intercept-only model (mean imputation). For numeric variables, missing values can be replaced with a simple mean, median, or mode of the observed data. For categorical variables, missing values can be replaced with a value randomly drawn from a binomial or multinomial distribution with the observed probabilities.

An imputation model can also be as complex as desired using a regularized regression model, a decision tree model, or K-nearest neighbors model. The main idea of a more complex prediction model is to find other observations as similar as to an observation with a missing value in terms of other predictors, and use data from these similar observations to predict the missing values. We will rely on some built-in functions in R to impute values using such complex models. For more information about its theoretical foundations, [Applied Missing Data Analysis by Craig Enders](http://www.appliedmissingdata.com/) provide a comprehensive coverage for this topic.


# 6. Wrapping-up using the `recipes` package

We can pre-process all the variables in the dataset manually using the approaches discussed earlier. However, this would be a tedious work. It may be overwhelming to apply all the procedures simulatenously to different training and test datasets. Instead, we can use the `recipes` package to implement these approaches in a more organized an efficient way. 

Before using the `recipes` package, there are a few things to do for this dataset.

1) Read the original data

2) Make a list of variables with different characteristics (binary, ordinal, nominal, continuous, proportions, etc.)

3) Transform all variables with binary, ordinal, and nominal outcome to a `factor`.

4) For variables that represent proportions, add/substract a small number to 0s/1s for logit transformation

5) Split the data into training and test datasets by using the filter variable provided in the original data to be consistent with the original competition. 

6) Remove the irrelevant variables not used (recidivism in year 1, year 3, and within 3 years) and filter variable for training/test split



```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

# 1) Read the original data

  recidivism <- read.csv('https://raw.githubusercontent.com/uo-datasci-specialization/c4-ml-fall-2021/main/data/recidivism_y1 removed.csv',
                         header=TRUE)
  
  str(recidivism)


# 2) List of variable types
  
  outcome <- c('Recidivism_Arrest_Year2')
  
  id      <- c('ID')
  
  nominal <- c('Residence_PUMA',
               'Prison_Offense')
  
  ordinal <- c('Age_at_Release',
               'Supervision_Level_First',
               'Education_Level',
               'Prison_Years')
  
  binary  <- c('Gender',
               'Race',
               'Gang_Affiliated',
               'Prior_Arrest_Episodes_DVCharges',
               'Prior_Arrest_Episodes_GunCharges',
               'Prior_Conviction_Episodes_Viol',
               'Prior_Conviction_Episodes_PPViolationCharges',
               'Prior_Conviction_Episodes_DomesticViolenceCharges',
               'Prior_Conviction_Episodes_GunCharges',
               'Prior_Revocations_Parole',
               'Prior_Revocations_Probation',
               'Condition_MH_SA',
               'Condition_Cog_Ed',
               'Condition_Other',
               'Violations_ElectronicMonitoring',
               'Violations_Instruction',
               'Violations_FailToReport',
               'Violations_MoveWithoutPermission',
               'Employment_Exempt') 

  numeric   <- c('Supervision_Risk_Score_First',
                 'Dependents',
                 'Prior_Arrest_Episodes_Felony',
                 'Prior_Arrest_Episodes_Misd',
                 'Prior_Arrest_Episodes_Violent',
                 'Prior_Arrest_Episodes_Property',
                 'Prior_Arrest_Episodes_Drug',
                 'Prior_Arrest_Episodes_PPViolationCharges',
                 'Prior_Conviction_Episodes_Felony',
                 'Prior_Conviction_Episodes_Misd',
                 'Prior_Conviction_Episodes_Prop',
                 'Prior_Conviction_Episodes_Drug',
                 'Delinquency_Reports',
                 'Program_Attendances',
                 'Program_UnexcusedAbsences',
                 'Residence_Changes',
                 'Avg_Days_per_DrugTest',
                 'Jobs_Per_Year')
  
  props      <- c('DrugTests_THC_Positive',
                  'DrugTests_Cocaine_Positive',
                  'DrugTests_Meth_Positive',
                  'DrugTests_Other_Positive',
                  'Percent_Days_Employed')
  
  
# 3) Convert all nominal, ordinal, and binary variables to factors
  # Leave the rest as is
  
  for(i in c(ordinal,nominal,binary)){
    
    recidivism[,i] <- as.factor(recidivism[,i])
    
  }

# 4) For variables that represent proportions, add/substract a small number
  # to 0s/1s for logit transformation
  
  for(i in props){
    recidivism[,i] <- ifelse(recidivism[,i]==0,.0001,recidivism[,i])
    recidivism[,i] <- ifelse(recidivism[,i]==1,.9999,recidivism[,i])
  }
  
# 5) training and test datasets

  d_tr <- recidivism[recidivism$Training_Sample==1,]
  d_te <- recidivism[recidivism$Training_Sample==0,]

  
# 6) Remove the irrelevant variables

  rm_var <- c('Recidivism_Within_3years','Recidivism_Arrest_Year1',
              'Recidivism_Arrest_Year3','Training_Sample')
  
  keep_var <- !colnames(recidivism)%in%rm_var
  
  d_tr <- d_tr[,keep_var]
  d_te <- d_te[,keep_var]
  
```


Now, we can apply certain transformations to different types of variables. We will use the `step_***()` functions from the `recipes` package to implement different procedures. Below is a list of functions for most procedures discussed earlier in this lecture. A more detailed list of `step_***()` functions can be found the in [the package manual](https://cran.r-project.org/web/packages/recipes/recipes.pdf).

- `step_dummy()`: creates dummy variables for one-hot encoding of categorical variables
- `step_indicate_na()` creates an indicator variable for missingness 
- `step_impute_bag()`, `step_impute_knn()`, `step_impute_linear()`, and `step_impute_mean()`: imputes missing values using an imputation model
- `step_BoxCox()`: transforms non-negative data using Box-Cox method
- `step_poly`,`step_bs()`, and `step_ns()` : creates basis expansions
- `step_logit`: applies logit transformation
- `step_zv`: removes variables with zero variance
- `step_normalize`: standardize variables to have a mean of zero and standard deviation of one

Note that the order of procedures applied to variables is important. For instance, there would be no meaning of using `step_indicate_na()` after using `step_impute_bag()` (Why?). Or, there will be a problem when you first standardize variables using 'step_normalize()` and then apply a Box-Cox transformation (Why?).

For this dataset, we will implement the following steps:

1) Create an indicator variable of missingness for all predictors (`step_indicate_na`)
2) Remove the variables with zero variance (`step_zv`)
2) Impute the missing values for all predictor variables using a mean or mode (`step_impute_mean` and `step_impute_mode`)
3) Logit transform the variables that represent proportions(`step_logit`)
4) Create natural splines for all numeric variables (`step_ns`)
5) Standardize numeric features
6) One-hot encoding of all categorical variables (`step_dummy`)

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

require(recipes)

blueprint <- recipe(x  = d_tr,
                    vars  = c(nominal,ordinal,binary,numeric,props,
                              'Recidivism_Arrest_Year2','ID'),
                    roles = c(rep('predictor',48),'outcome','ID')) %>%
  
  # for all 48 predictors, create an indicator variable for missingness

  step_indicate_na(all_of(nominal),all_of(ordinal),all_of(binary),all_of(numeric),all_of(props)) %>%
  
  # Remove the variable with zero variance, this will also remove the missingness 
  # variables if there is no missingess

  step_zv(all_numeric()) %>%
  
  # Impute the missing values using mean and mode. You can instead use a 
  # more advanced imputation model such as bagged trees. I haven't used it due
  # to time concerns
  
  step_impute_mean(all_of(numeric),all_of(props)) %>%
  step_impute_mode(all_of(nominal),all_of(ordinal),all_of(binary)) %>%
  
  #Logit transformation of proportions
  
  step_logit(all_of(props)) %>%
  
  # Natural splines for numeric variables and proportions
  
  step_ns(all_of(numeric),all_of(props),deg_free=3) %>%
  
  # Standardize the natural splines of numeric variables and proportions
  
  step_normalize(paste0(numeric,'_ns_1'),
                 paste0(numeric,'_ns_2'),
                 paste0(numeric,'_ns_3'),
                 paste0(props,'_ns_1'),
                 paste0(props,'_ns_2'),
                 paste0(props,'_ns_3')) %>%
  
  # One-hot encoding for all categorical variables
  
  step_dummy(all_of(nominal),all_of(ordinal),all_of(binary),one_hot=TRUE)



blueprint

```

Once the recipe is ready, we can train the blueprint on training data. When we say 'train' it means that weights or statistics for certain types of operations (e.g., standardization) are calculated based on training data and saved for later use. For instance, the mean and standard deviation of variable X from training data is calculated and later used to standardize the same variable X in testing data or future datasets.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

prepare <- prep(blueprint, 
                training = d_tr)
prepare

```

Finally, we can apply this recipe to our training and test datasets to obtain processed variables accordingly to use in modeling later.

```{r, echo=TRUE,eval=TRUE,class.source='klippy',class.source = 'fold-show',message=FALSE, warning=FALSE}

baked_train <- bake(prepare, new_data = d_tr)
baked_test  <- bake(prepare, new_data = d_te)

baked_train

baked_test
```

Notice that there are 167 variables (one outcome, one ID, and 165 predictors) in the new processed datasets. In the original dataset, there were 48 predictors. Below is a breakdown of where these 165 variables come from.

| Variable Name                                      | Encoding | Number of Categories | Process         | Number of Constructed Variables |
|:--------------------------------------------------:|:--------:|:--------------------:|:---------------:|:-------------------------------:|
| Gender                                             |Binary    |        2             |One-hot encoding |               2                 |
| Race                                               |Binary    |        2             |One-hot encoding |               2                 |
| Gang affiliation                                   |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Arrest_Episodes_DVCharges                    |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Arrest_Episodes_GunCharges                   |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Conviction_Episodes_Viol                     |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Conviction_Episodes_PPViolationCharges       |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Conviction_Episodes_DomesticViolenceCharges  |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Conviction_Episodes_GunCharges               |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Revocations_Parole                           |Binary    |        2             |One-hot encoding |               2                 |
| Prior_Revocations_Probation                        |Binary    |        2             |One-hot encoding |               2                 |
| Condition_MH_SA                                    |Binary    |        2             |One-hot encoding |               2                 |
| Condition_Cog_Ed                                   |Binary    |        2             |One-hot encoding |               2                 |
| Condition_Other                                    |Binary    |        2             |One-hot encoding |               2                 |
| Violations_ElectronicMonitoring                    |Binary    |        2             |One-hot encoding |               2                 |
| Violations_Instruction                             |Binary    |        2             |One-hot encoding |               2                 |
| Violations_FailToReport                            |Binary    |        2             |One-hot encoding |               2                 |
| Violations_MoveWithoutPermission                   |Binary    |        2             |One-hot encoding |               2                 |
| Employment_Exempt                                  |Binary    |        2             |One-hot encoding |               2                 |
|                                                    |          |                      |                 |                                 |
|                                                    |          |                      |                 |                                 |
| Age_at_Release                                     |Ordinal   |        7             |One-hot encoding |               7                 |
| Supervision_Level_First                            |Ordinal   |        3             |One-hot encoding |               3                 |
| Education_Level                                    |Ordinal   |        3             |One-hot encoding |               3                 |
| Prison_Years                                       |Ordinal   |        4             |One-hot encoding |               4                 |
|                                                    |          |                      |                 |                                 |
|                                                    |          |                      |                 |                                 |
| Residence_PUMA                                     |Nominal   |       25             |One-hot encoding |              25                 |
| Prison_Offense                                     |Nominal   |        5             |One-hot encoding |               5                 |
|                                                    |          |                      |                 |                                 |
|                                                    |          |                      |                 |                                 |
|                                                    |          |                      |                 |                                 |                
| Supervision_Risk_Score_First                       |Numeric   |                      | Natural Splines, Standardization |    3           |
| Dependents                                         |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Arrest_Episodes_Felony                       |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Arrest_Episodes_Misd                         |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Arrest_Episodes_Violent                      |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Arrest_Episodes_Property                     |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Arrest_Episodes_Drug                         |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Arrest_Episodes_PPViolationCharges           |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Conviction_Episodes_Felony                   |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Conviction_Episodes_Misd                     |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Conviction_Episodes_Prop                     |Numeric   |                      | Natural Splines, Standardization |    3           |
| Prior_Conviction_Episodes_Drug                     |Numeric   |                      | Natural Splines, Standardization |    3           |
| Delinquency_Reports                                |Numeric   |                      | Natural Splines, Standardization |    3           |
| Program_Attendances                                |Numeric   |                      | Natural Splines, Standardization |    3           |
| Program_UnexcusedAbsences                          |Numeric   |                      | Natural Splines, Standardization |    3           |
| Residence_Changes                                  |Numeric   |                      | Natural Splines, Standardization |    3           |
| Avg_Days_per_DrugTest                              |Numeric   |                      | Natural Splines, Standardization |    3           |
| Jobs_Per_Year                                      |Numeric   |                      | Natural Splines, Standardization |    3           |
| DrugTests_THC_Positive                             |Numeric   |                      | Natural Splines, Standardization |    3           |
| DrugTests_Cocaine_Positive                         |Numeric   |                      | Natural Splines, Standardization |    3           |
| DrugTests_Meth_Positive                            |Numeric   |                      | Natural Splines, Standardization |    3           |
| DrugTests_Other_Positive                           |Numeric   |                      | Natural Splines, Standardization |    3           |
| Percent_Days_Employed                              |Numeric   |                      | Natural Splines, Standardization |    3           |
|                                                    |          |                      |                 |                                 |
|                                                    |          |                      |                 |                                 |
| Missing value indicator variables                  |Binary    |                      |                 |               11                |
|                                                    |          |                      |                 |                                 |
|                                                    |          |                      |      Total      |              165                |


